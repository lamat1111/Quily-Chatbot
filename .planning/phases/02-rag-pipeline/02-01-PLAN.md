---
phase: 02-rag-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/rag/types.ts
  - src/lib/rag/retriever.ts
  - src/lib/supabase.ts
autonomous: true

must_haves:
  truths:
    - "Query embedding matches documents via match_document_chunks RPC"
    - "Retriever returns chunks with source metadata and citation indices"
    - "Reranking optional based on Cohere key availability"
  artifacts:
    - path: "src/lib/rag/types.ts"
      provides: "RetrievedChunk interface, RAG configuration types"
      exports: ["RetrievedChunk", "RetrievalOptions"]
    - path: "src/lib/rag/retriever.ts"
      provides: "Two-stage retrieval with optional Cohere reranking"
      exports: ["retrieveWithReranking"]
    - path: "src/lib/supabase.ts"
      provides: "Supabase client singleton"
      exports: ["supabase"]
  key_links:
    - from: "src/lib/rag/retriever.ts"
      to: "match_document_chunks RPC"
      via: "supabase.rpc()"
      pattern: "supabase\\.rpc\\(['\"]match_document_chunks"
    - from: "src/lib/rag/retriever.ts"
      to: "@ai-sdk/cohere"
      via: "rerank() function"
      pattern: "rerank\\("
---

<objective>
Create the RAG retrieval layer: types, Supabase client, and two-stage retriever with optional reranking.

Purpose: Foundation for semantic search - given a query, find and rank the most relevant documentation chunks.
Output: Working retriever module that can be called with a query string and returns citation-indexed chunks.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-rag-pipeline/02-RESEARCH.md

# Phase 1 outputs needed
@scripts/ingest/types.ts
@scripts/db/schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create RAG types</name>
  <files>package.json, src/lib/rag/types.ts</files>
  <action>
1. Install required packages:
   ```bash
   npm install @ai-sdk/cohere zod
   ```

2. Create `src/lib/rag/types.ts` with:
   - `RetrievedChunk` interface matching what `match_document_chunks` returns plus `citationIndex`:
     ```typescript
     export interface RetrievedChunk {
       id: number;
       content: string;
       source_file: string;
       heading_path: string | null;
       similarity: number;
       citationIndex: number;
     }
     ```
   - `RetrievalOptions` interface:
     ```typescript
     export interface RetrievalOptions {
       embeddingApiKey: string;
       cohereApiKey?: string;
       initialCount?: number;  // default 15
       finalCount?: number;    // default 5
       similarityThreshold?: number;  // default 0.5
     }
     ```
   - `SourceReference` interface for client display:
     ```typescript
     export interface SourceReference {
       index: number;
       file: string;
       heading: string | null;
       url: string | null;
     }
     ```

Note: Do NOT re-export types from scripts/ingest/types.ts - the RAG layer has its own types for different concerns.
  </action>
  <verify>
`npm ls @ai-sdk/cohere zod` shows both installed.
`cat src/lib/rag/types.ts` shows RetrievedChunk, RetrievalOptions, SourceReference exports.
`npx tsc --noEmit` passes.
  </verify>
  <done>Dependencies installed, RAG types defined and type-check passes</done>
</task>

<task type="auto">
  <name>Task 2: Create Supabase client singleton</name>
  <files>src/lib/supabase.ts</files>
  <action>
Create `src/lib/supabase.ts` with:

```typescript
import { createClient } from '@supabase/supabase-js';

if (!process.env.NEXT_PUBLIC_SUPABASE_URL) {
  throw new Error('Missing NEXT_PUBLIC_SUPABASE_URL');
}
if (!process.env.SUPABASE_SERVICE_ROLE_KEY) {
  throw new Error('Missing SUPABASE_SERVICE_ROLE_KEY');
}

export const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);
```

Why service role key: Server-side operations need service role, not anon key. This client is only used in API routes, never exposed to browser.

Update `.env.example` to include the new env vars if not present:
- `NEXT_PUBLIC_SUPABASE_URL=`
- `SUPABASE_SERVICE_ROLE_KEY=`
  </action>
  <verify>
`cat src/lib/supabase.ts` shows createClient with env vars.
`cat .env.example | grep SUPABASE` shows both vars.
  </verify>
  <done>Supabase client exports `supabase` singleton with proper env var checks</done>
</task>

<task type="auto">
  <name>Task 3: Create retriever module with two-stage retrieval</name>
  <files>src/lib/rag/retriever.ts</files>
  <action>
Create `src/lib/rag/retriever.ts` implementing two-stage retrieval:

1. Import dependencies:
   - `embed, rerank` from 'ai'
   - `cohere` from '@ai-sdk/cohere'
   - `createOpenRouter` from '@openrouter/ai-sdk-provider'
   - `supabase` from '../supabase'
   - Types from './types'

2. Export `retrieveWithReranking(query: string, options: RetrievalOptions): Promise<RetrievedChunk[]>`:

   Stage 1 - Vector search:
   - Create OpenRouter provider with `options.embeddingApiKey`
   - Use `embed()` with `openrouter.textEmbeddingModel('openai/text-embedding-3-small')` to embed query
   - Call `supabase.rpc('match_document_chunks', {...})` with embedding
   - Use `options.initialCount` (default 15) for match_count
   - Use `options.similarityThreshold` (default 0.5) for match_threshold
   - Handle error: throw Error with message

   Stage 2 - Optional reranking:
   - If `options.cohereApiKey` provided AND candidates.length > finalCount:
     - Use `rerank({ model: cohere.reranking('rerank-v3.5'), query, documents: candidates.map(c => c.content), topN: options.finalCount })`
     - Map rerankedDocuments back using `originalIndex` to preserve metadata
     - Add `citationIndex: idx + 1` to each result
   - Else (no Cohere key or not enough candidates):
     - Take top N by similarity (slice)
     - Add `citationIndex: idx + 1`

   Return array of RetrievedChunk.

3. Handle Cohere API key via environment:
   - Check `process.env.COHERE_API_KEY` as fallback if not in options
   - This allows server-side Cohere key without requiring user to provide it

IMPORTANT: The embedding model MUST be 'openai/text-embedding-3-small' to match Phase 1 ingestion. Using a different model will cause similarity mismatch.
  </action>
  <verify>
`cat src/lib/rag/retriever.ts` shows:
- embed() call with 'openai/text-embedding-3-small'
- supabase.rpc('match_document_chunks', ...)
- rerank() call with cohere.reranking('rerank-v3.5')
- Fallback path for no Cohere key
- citationIndex assignment

`npx tsc --noEmit` passes.
  </verify>
  <done>
Retriever module exports retrieveWithReranking function that:
- Embeds query with same model as ingestion
- Calls match_document_chunks RPC
- Optionally reranks with Cohere
- Returns chunks with citation indices
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `npm ls @ai-sdk/cohere zod` - dependencies installed
2. `npx tsc --noEmit` - no type errors
3. File structure exists:
   - src/lib/rag/types.ts
   - src/lib/rag/retriever.ts
   - src/lib/supabase.ts
</verification>

<success_criteria>
- Dependencies @ai-sdk/cohere and zod installed
- RAG types (RetrievedChunk, RetrievalOptions, SourceReference) exported
- Supabase client singleton exported
- Retriever function implements two-stage retrieval
- Code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-rag-pipeline/02-01-SUMMARY.md`
</output>
