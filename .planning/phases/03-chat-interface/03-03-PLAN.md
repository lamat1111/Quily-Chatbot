---
phase: 03-chat-interface
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/components/chat/ChatContainer.tsx
  - src/components/chat/MessageList.tsx
  - src/components/chat/MessageBubble.tsx
  - src/components/chat/ChatInput.tsx
  - src/components/chat/SourcesCitation.tsx
  - src/components/chat/TypingIndicator.tsx
  - src/components/chat/MarkdownRenderer.tsx
autonomous: true

must_haves:
  truths:
    - "User can type a question and submit it"
    - "Response streams character-by-character"
    - "Typing indicator displays while streaming"
    - "User can stop generation mid-stream"
    - "Responses render with markdown formatting"
    - "Code blocks have syntax highlighting"
    - "Sources display in expandable footer"
  artifacts:
    - path: "src/components/chat/ChatContainer.tsx"
      provides: "Main chat orchestration with useChat"
      exports: ["ChatContainer"]
    - path: "src/components/chat/MessageList.tsx"
      provides: "Scrollable message area"
      exports: ["MessageList"]
    - path: "src/components/chat/ChatInput.tsx"
      provides: "Input form with stop button"
      exports: ["ChatInput"]
    - path: "src/components/chat/MarkdownRenderer.tsx"
      provides: "Markdown with syntax highlighting"
      exports: ["MarkdownRenderer"]
  key_links:
    - from: "src/components/chat/ChatContainer.tsx"
      to: "/api/chat"
      via: "useChat hook"
      pattern: "useChat.*api.*chat"
    - from: "src/components/chat/MarkdownRenderer.tsx"
      to: "react-markdown"
      via: "import"
      pattern: "import.*react-markdown"
    - from: "src/components/chat/MessageList.tsx"
      to: "src/hooks/useScrollAnchor.ts"
      via: "hook"
      pattern: "useScrollAnchor"
---

<objective>
Build chat components: message display, input form, markdown rendering, and streaming integration.

Purpose: Core chat functionality - users send messages, see streaming responses with markdown/code rendering.
Output: Complete chat UI with streaming, stop button, auto-scroll, and rich content rendering.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-chat-interface/03-CONTEXT.md
@.planning/phases/03-chat-interface/03-RESEARCH.md

# Existing API route
@app/api/chat/route.ts

# Dependencies from Plan 01
@src/hooks/useLocalStorage.ts
@src/hooks/useScrollAnchor.ts
@src/stores/conversationStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MarkdownRenderer and SourcesCitation components</name>
  <files>
    src/components/chat/MarkdownRenderer.tsx
    src/components/chat/SourcesCitation.tsx
    src/components/chat/TypingIndicator.tsx
  </files>
  <action>
Create `src/components/chat/MarkdownRenderer.tsx`:
- Props: `content: string`
- Use react-markdown with remarkGfm plugin
- Custom `code` component override:
  - Detect language from className (pattern: /language-(\w+)/)
  - For block code with language: use SyntaxHighlighter with oneDark theme
  - For inline code: simple `<code>` with gray background
  - Import from 'react-syntax-highlighter/dist/esm/styles/prism' for oneDark
- Handle other markdown elements with Tailwind classes:
  - Headers: font-bold, appropriate sizes
  - Lists: list-disc/list-decimal with pl-6
  - Links: text-blue-600, hover:underline, target="_blank"
  - Paragraphs: mb-4

Create `src/components/chat/SourcesCitation.tsx`:
- Props: `sources: Array<{ sourceId: string; url: string; title?: string }>`
- State: `expanded` (boolean, default false)
- Display:
  - Clickable "N sources" text (toggles expanded)
  - When expanded: list of source links
  - Each source: clickable title/url, opens in new tab
  - rel="noopener noreferrer" for security
- Tailwind: border-t, pt-3, mt-3, text-sm, text-blue-600

Create `src/components/chat/TypingIndicator.tsx`:
- Props: none
- Simple animated dots (3 dots with staggered animation)
- Use Tailwind animation classes or keyframes
- Text: "Thinking..." with animated dots
  </action>
  <verify>
TypeScript compiles: `npm run typecheck` passes.
  </verify>
  <done>
MarkdownRenderer renders markdown with syntax-highlighted code blocks.
SourcesCitation shows expandable source list.
TypingIndicator shows animated loading state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MessageBubble and MessageList components</name>
  <files>
    src/components/chat/MessageBubble.tsx
    src/components/chat/MessageList.tsx
  </files>
  <action>
Create `src/components/chat/MessageBubble.tsx`:
- Props: `message` (from useChat - has role, content, parts)
- Per CONTEXT.md: both left-aligned, different background colors
- User messages: blue background (bg-blue-600), white text
- Assistant messages: gray background (bg-gray-100), dark text
- Max width: 80% of container
- For assistant messages:
  - Render content through MarkdownRenderer
  - Extract source-url parts from message.parts
  - Show SourcesCitation if sources exist (after streaming completes)
- For user messages:
  - Simple whitespace-pre-wrap paragraph
- Rounded corners, padding

Create `src/components/chat/MessageList.tsx`:
- Props: `messages` array, `status` (from useChat), `error` (Error | null)
- Use useScrollAnchor hook for auto-scroll behavior
- Auto-scroll during streaming ONLY if user is at bottom
- Display messages in order
- Show TypingIndicator when status === 'streaming' or 'submitted'
- Show error message if error exists (red text, clear message)
- Empty state: centered "Ask a question about Quilibrium to get started"
- Invisible anchor div at bottom for intersection observer
- Overflow-y-auto, flex-1 to fill available space
  </action>
  <verify>
TypeScript compiles: `npm run typecheck` passes.
  </verify>
  <done>
MessageBubble renders user and assistant messages with proper styling.
MessageList handles scroll behavior and displays streaming indicator.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ChatInput and ChatContainer components</name>
  <files>
    src/components/chat/ChatInput.tsx
    src/components/chat/ChatContainer.tsx
  </files>
  <action>
Create `src/components/chat/ChatInput.tsx`:
- Props: `onSubmit: (text: string) => void`, `onStop: () => void`, `isStreaming: boolean`, `disabled: boolean`
- Local state: `input` string
- Form with input + button
- Input: flex-1, border, rounded, focus ring
- Placeholder changes based on disabled state
- Submit button: blue when enabled, gray when disabled
- Stop button (red): shows instead of submit when streaming
- Handle form submit: call onSubmit, clear input
- Disable input during streaming
- Per CONTEXT.md: fixed at bottom, always visible

Create `src/components/chat/ChatContainer.tsx`:
- 'use client' directive
- Props: `apiKey: string`, `model: string`, `conversationId: string | null`
- Use `useChat` from @ai-sdk/react
- Configure useChat:
  - api: '/api/chat'
  - body: { apiKey, model } - sent with every request
  - id: conversationId or 'new-chat' (unique per conversation)
- Extract from useChat: messages, append, status, stop, error
- Handle message submission: call append with role: 'user', content: text
- Sync messages to conversation store when they change (if conversationId exists)
- Layout:
  - MessageList fills space (flex-1)
  - ChatInput fixed at bottom
- Disabled state when no API key
  </action>
  <verify>
TypeScript compiles: `npm run typecheck` passes.
  </verify>
  <done>
ChatInput handles user input with submit/stop functionality.
ChatContainer orchestrates chat with useChat hook and syncs to store.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes
2. All files exist:
   - src/components/chat/MarkdownRenderer.tsx
   - src/components/chat/SourcesCitation.tsx
   - src/components/chat/TypingIndicator.tsx
   - src/components/chat/MessageBubble.tsx
   - src/components/chat/MessageList.tsx
   - src/components/chat/ChatInput.tsx
   - src/components/chat/ChatContainer.tsx
3. Each component has 'use client' directive where needed
4. ChatContainer uses useChat hook
5. MarkdownRenderer uses react-markdown
</verification>

<success_criteria>
- User can type and submit messages (CHAT-01)
- Response streams character-by-character (CHAT-02)
- Typing indicator shows during streaming (CHAT-03)
- Stop button halts generation (CHAT-05)
- Markdown renders correctly (RENDER-01)
- Code blocks have syntax highlighting (RENDER-02)
- Sources show in expandable footer
</success_criteria>

<output>
After completion, create `.planning/phases/03-chat-interface/03-03-SUMMARY.md`
</output>
