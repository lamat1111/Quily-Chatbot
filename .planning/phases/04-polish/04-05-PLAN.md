---
phase: 04-polish
plan: 05
type: execute
wave: 3
depends_on: ["04-01", "04-02", "04-03", "04-04"]
files_modified:
  - src/components/chat/ChatInput.tsx
  - src/components/chat/ChatContainer.tsx
  - app/page.tsx
autonomous: false

must_haves:
  truths:
    - "Ctrl/Cmd+Enter sends message from anywhere on page"
    - "Escape stops streaming from anywhere on page"
    - "Loading skeletons show during initial page load"
    - "All polish features work together in integrated app"
  artifacts:
    - path: "src/components/chat/ChatContainer.tsx"
      provides: "Global keyboard shortcut handling"
      contains: "useEffect.*keydown"
    - path: "app/page.tsx"
      provides: "Skeleton loading during hydration"
      contains: "MessageListSkeleton|ChatSkeleton"
  key_links:
    - from: "ChatContainer.tsx"
      to: "window.addEventListener"
      via: "global keydown handler"
      pattern: "addEventListener.*keydown"
    - from: "page.tsx"
      to: "Skeleton"
      via: "import and conditional render"
      pattern: "import.*Skeleton"
---

<objective>
Add keyboard shortcuts, loading skeletons, and perform final integration verification.

Purpose: Satisfies POLISH-02 (keyboard shortcuts) and POLISH-03 (loading skeletons). Final plan ensures all polish features work together.

Output: Keyboard shortcuts work globally, skeletons show during load, all Phase 4 requirements verified.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-polish/04-RESEARCH.md

# Prior plan summaries
@.planning/phases/04-polish/04-01-SUMMARY.md
@.planning/phases/04-polish/04-02-SUMMARY.md
@.planning/phases/04-polish/04-03-SUMMARY.md
@.planning/phases/04-polish/04-04-SUMMARY.md

# Files we're modifying
@src/components/chat/ChatInput.tsx
@src/components/chat/ChatContainer.tsx
@app/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add global keyboard shortcuts to ChatContainer</name>
  <files>src/components/chat/ChatContainer.tsx</files>
  <action>
Update `src/components/chat/ChatContainer.tsx` to add global keyboard shortcuts:

1. Add useEffect for global keyboard event handling:

```typescript
// Global keyboard shortcuts
useEffect(() => {
  const handleKeyDown = (e: KeyboardEvent) => {
    // Escape to stop streaming
    if (e.key === 'Escape' && status === 'streaming') {
      e.preventDefault();
      stop();
      return;
    }

    // Ctrl/Cmd+Enter to submit (works from anywhere on page)
    const isModifier = e.ctrlKey || e.metaKey;
    if (isModifier && e.key === 'Enter') {
      // Don't trigger if already streaming or no input
      // Need to get current input value - this requires lifting state or using ref
      // For now, focus the textarea and let its handler work
      const textarea = document.querySelector('textarea');
      if (textarea && !status === 'streaming') {
        textarea.focus();
        // Dispatch a synthetic submit
        const form = textarea.closest('form');
        if (form) {
          form.dispatchEvent(new Event('submit', { bubbles: true, cancelable: true }));
        }
      }
      e.preventDefault();
    }
  };

  window.addEventListener('keydown', handleKeyDown);
  return () => window.removeEventListener('keydown', handleKeyDown);
}, [status, stop]);
```

Alternative approach (better): Add an inputRef to ChatInput and expose submit method via useImperativeHandle, then call from ChatContainer. But simpler approach for now:

2. Actually, better to keep keyboard handling in ChatInput for submit (it already handles Enter), and only add Escape globally:

```typescript
// Global Escape to stop
useEffect(() => {
  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.key === 'Escape' && status === 'streaming') {
      e.preventDefault();
      stop();
    }
  };

  window.addEventListener('keydown', handleKeyDown);
  return () => window.removeEventListener('keydown', handleKeyDown);
}, [status, stop]);
```

3. For Ctrl/Cmd+Enter, update ChatInput to handle it in the textarea's onKeyDown (Task 2).

The global Escape is most important since user might have focus elsewhere when they want to stop generation.
  </action>
  <verify>
- `npx tsc --noEmit` passes
- When streaming, pressing Escape stops generation
  </verify>
  <done>Global Escape shortcut stops streaming</done>
</task>

<task type="auto">
  <name>Task 2: Update ChatInput for Ctrl/Cmd+Enter shortcut</name>
  <files>src/components/chat/ChatInput.tsx</files>
  <action>
Update `src/components/chat/ChatInput.tsx` to support Ctrl/Cmd+Enter:

1. Modify handleKeyDown to check for modifier key:

```typescript
const handleKeyDown = (e: KeyboardEvent<HTMLTextAreaElement>) => {
  // Submit on Enter (without Shift) OR Ctrl/Cmd+Enter
  const isModifierEnter = (e.ctrlKey || e.metaKey) && e.key === 'Enter';
  const isPlainEnter = e.key === 'Enter' && !e.shiftKey;

  if (isModifierEnter || isPlainEnter) {
    e.preventDefault();
    handleSubmit(e as unknown as FormEvent);
  }
};
```

This means:
- Enter (no modifiers) = submit
- Shift+Enter = new line (browser default, we don't preventDefault)
- Ctrl+Enter = submit
- Cmd+Enter = submit (Mac)

2. Add visual hint in placeholder or as helper text about keyboard shortcut:
   - Could add small text below input: "Press Enter to send, Shift+Enter for new line"
   - Or add tooltip to Send button
   - Keep it subtle - most users discover these naturally

For now, keep it simple - the shortcut works, power users will find it.

3. Update input styling to be theme-aware if not already:
   - bg-gray-800 -> bg-white dark:bg-gray-800
   - text-gray-100 -> text-gray-900 dark:text-gray-100
   - border-gray-600 -> border-gray-300 dark:border-gray-600
   - placeholder-gray-400 -> placeholder-gray-500 dark:placeholder-gray-400

4. Update container div and form to be theme-aware:
   - bg-gray-900 -> bg-gray-50 dark:bg-gray-900
   - border-gray-700 -> border-gray-200 dark:border-gray-700
  </action>
  <verify>
- `npx tsc --noEmit` passes
- Ctrl+Enter submits message
- Cmd+Enter submits on Mac
- Shift+Enter creates new line
- Plain Enter still submits
  </verify>
  <done>ChatInput supports Ctrl/Cmd+Enter keyboard shortcut</done>
</task>

<task type="auto">
  <name>Task 3: Add loading skeletons to page</name>
  <files>app/page.tsx</files>
  <action>
Update `app/page.tsx` to show skeletons during initial load:

1. Import skeleton components:
   ```typescript
   import { ChatSkeleton } from '@/src/components/ui/Skeleton';
   ```

2. The page likely already has some loading state handling. Add skeleton for chat area during hydration:

```typescript
'use client';

import { useState, useEffect } from 'react';
import { Sidebar } from '@/src/components/sidebar/Sidebar';
import { ChatContainer } from '@/src/components/chat/ChatContainer';
import { ChatSkeleton } from '@/src/components/ui/Skeleton';

export default function Home() {
  const [isHydrated, setIsHydrated] = useState(false);

  useEffect(() => {
    setIsHydrated(true);
  }, []);

  return (
    <main className="h-screen flex bg-white dark:bg-gray-900">
      <Sidebar />
      <div className="flex-1 flex flex-col">
        {isHydrated ? (
          <ChatContainer />
        ) : (
          <ChatSkeleton />
        )}
      </div>
    </main>
  );
}
```

3. Make page background theme-aware:
   - bg-gray-900 -> bg-white dark:bg-gray-900

4. Consider also showing skeleton for sidebar conversation list, but that's lower priority. Focus on chat area.

Note: The skeleton only shows during initial hydration, which is typically very fast. It prevents layout shift and provides visual continuity.
  </action>
  <verify>
- `npx tsc --noEmit` passes
- `npm run build` succeeds
- Page shows skeleton briefly on initial load
- Skeleton transitions to chat container smoothly
  </verify>
  <done>Loading skeleton shows during initial hydration</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Phase 4 Polish features:
- Light/dark mode toggle in sidebar
- Copy buttons on code blocks (hover reveal)
- Copy button on assistant messages
- API key modal with OpenRouter info
- Ctrl/Cmd+Enter to send
- Escape to stop streaming
- Loading skeletons during page load
</what-built>
  <how-to-verify>
1. Visit http://localhost:3000

**Theme Toggle (RENDER-05):**
2. Find theme toggle button in sidebar
3. Click to switch between light and dark modes
4. Verify all colors update correctly
5. Refresh page - theme persists

**Copy Code (RENDER-04):**
6. Send a message that triggers code in response (e.g., "Show me a hello world in Python")
7. Hover over code block - copy button appears
8. Click copy button - checkmark appears
9. Paste somewhere - code is copied

**Copy Message (POLISH-01):**
10. Look at assistant message header
11. Click copy button - checkmark appears
12. Paste somewhere - full response is copied

**API Key Modal (POLISH-04):**
13. Click API key button in sidebar
14. Modal opens with OpenRouter explanation
15. Verify link to openrouter.ai/settings/keys works
16. Press Escape - modal closes
17. Click outside modal - modal closes

**Keyboard Shortcuts (POLISH-02):**
18. Type a message but don't send
19. Press Ctrl+Enter (or Cmd+Enter on Mac) - message sends
20. While response is streaming, press Escape - streaming stops

**Loading Skeleton (POLISH-03):**
21. Hard refresh page (Cmd+Shift+R or Ctrl+Shift+R)
22. Look for brief skeleton animation before content appears
23. (May be very fast - that's OK)

**Overall:**
24. Test in both light and dark modes
25. Test on mobile viewport (resize browser)
26. Check console for any errors
  </how-to-verify>
  <resume-signal>Type "approved" if all features work, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
All Phase 4 requirements verified:
- [ ] RENDER-04: Copy code snippets with one click
- [ ] RENDER-05: Light/dark mode toggle
- [ ] POLISH-01: Copy entire assistant response
- [ ] POLISH-02: Keyboard shortcuts (Ctrl/Cmd+Enter, Escape)
- [ ] POLISH-03: Loading skeletons
- [ ] POLISH-04: API key modal with OpenRouter info
</verification>

<success_criteria>
All 6 Phase 4 requirements are satisfied and verified by user.
No console errors.
Works in both light and dark modes.
Works on mobile viewport.
</success_criteria>

<output>
After completion, create `.planning/phases/04-polish/04-05-SUMMARY.md`
</output>
